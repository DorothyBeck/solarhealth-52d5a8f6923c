"use client";

import { ethers } from "ethers";
import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// ABI files will be generated by genabi script
import { SolarHealthABI } from "@/abi/SolarHealthABI";
import { SolarHealthAddresses } from "@/abi/SolarHealthAddresses";

type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type SolarHealthInfoType = {
  abi: any[];
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

function getSolarHealthByChainId(
  chainId: number | undefined
): SolarHealthInfoType {
  if (!chainId) {
    return { abi: SolarHealthABI.abi as unknown as any[] || [] };
  }

  const entry =
    SolarHealthAddresses[chainId.toString() as keyof typeof SolarHealthAddresses];

  if (!entry || !entry.address || entry.address === ethers.ZeroAddress) {
    return { abi: SolarHealthABI.abi as unknown as any[] || [], chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: SolarHealthABI.abi as unknown as any[] || [],
  };
}

export const useSolarHealth = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
  } = parameters;

  const [isRecording, setIsRecording] = useState<boolean>(false);
  const [isCalculating, setIsCalculating] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const solarHealth = useMemo(() => {
    const c = getSolarHealthByChainId(chainId);
    if (!c.address) {
      setMessage(`SolarHealth deployment not found for chainId=${chainId}.`);
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!solarHealth) return false;
    return !!solarHealth.address;
  }, [solarHealth]);

  const contract = useMemo(() => {
    if (!ethersReadonlyProvider || !solarHealth.address || !solarHealth.abi.length) {
      return null;
    }
    return new ethers.Contract(
      solarHealth.address,
      solarHealth.abi,
      ethersSigner || ethersReadonlyProvider
    );
  }, [ethersReadonlyProvider, ethersSigner, solarHealth]);

  // Record health data
  const recordHealthData = useCallback(
    async (date: number, category: number, value: number) => {
      if (!instance) {
        const error = new Error("FHEVM instance not available");
        setMessage(error.message);
        throw error;
      }
      if (!contract) {
        const error = new Error("Contract not available. Please deploy SolarHealth contract first.");
        setMessage(error.message);
        throw error;
      }
      if (!ethersSigner) {
        const error = new Error("Wallet not connected");
        setMessage(error.message);
        throw error;
      }

      setIsRecording(true);
      setMessage("Encrypting data...");

      try {
        const contractAddress = await contract.getAddress();
        const signerAddress = await ethersSigner.getAddress();
        
        // Create encrypted input using FHEVM API
        const input = instance.createEncryptedInput(
          contractAddress,
          signerAddress
        );
        input.add16(value);
        
        setMessage("Encrypting (this may take a moment)...");
        // Encrypt (CPU-intensive)
        const enc = await input.encrypt();

        setMessage("Submitting transaction...");
        // Call contract
        const tx = await contract.recordHealthData(
          date,
          category,
          enc.handles[0],
          enc.inputProof
        );

        setMessage("Waiting for confirmation...");
        await tx.wait();
        setMessage("Health data recorded successfully!");
      } catch (error: any) {
        const errorMsg = error?.reason || error?.message || error?.toString() || "Failed to record data";
        setMessage(`Error: ${errorMsg}`);
        throw error;
      } finally {
        setIsRecording(false);
      }
    },
    [instance, contract, ethersSigner]
  );

  // Record steps (euint32)
  const recordSteps = useCallback(
    async (date: number, steps: number) => {
      if (!instance) {
        const error = new Error("FHEVM instance not available");
        setMessage(error.message);
        throw error;
      }
      if (!contract) {
        const error = new Error("Contract not available. Please deploy SolarHealth contract first.");
        setMessage(error.message);
        throw error;
      }
      if (!ethersSigner) {
        const error = new Error("Wallet not connected");
        setMessage(error.message);
        throw error;
      }

      setIsRecording(true);
      setMessage("Encrypting steps...");

      try {
        const contractAddress = await contract.getAddress();
        const signerAddress = await ethersSigner.getAddress();
        
        // Create encrypted input for euint32
        const input = instance.createEncryptedInput(
          contractAddress,
          signerAddress
        );
        input.add32(steps);
        
        setMessage("Encrypting (this may take a moment)...");
        // Encrypt
        const enc = await input.encrypt();

        setMessage("Submitting transaction...");
        const tx = await contract.recordSteps(
          date,
          enc.handles[0],
          enc.inputProof
        );

        setMessage("Waiting for confirmation...");
        await tx.wait();
        setMessage("Steps recorded successfully!");
      } catch (error: any) {
        const errorMsg = error?.reason || error?.message || error?.toString() || "Failed to record steps";
        setMessage(`Error: ${errorMsg}`);
        throw error;
      } finally {
        setIsRecording(false);
      }
    },
    [instance, contract, ethersSigner]
  );

  // Calculate average
  const calculateAverage = useCallback(
    async (dates: number[], category: number) => {
      if (!instance || !contract || !ethersSigner) {
        setMessage("FHEVM instance or contract not available");
        return null;
      }

      setIsCalculating(true);
      setMessage("");

      try {
        const contractAddress = await contract.getAddress();
        
        console.log("[useSolarHealth] Calling calculateAverage with dates:", dates, "category:", category);
        setMessage("Calling contract...");
        
        // IMPORTANT: staticCall() doesn't execute FHE.allow, so we MUST send a real transaction
        // to ensure the authorization (FHE.allow) is executed on-chain
        // First, try staticCall to get the handle for quick feedback
        let handle: string;
        try {
          handle = await contract.calculateAverage.staticCall(dates, category);
          console.log("[useSolarHealth] Got handle from staticCall (preview):", handle);
        } catch (staticCallError: any) {
          console.log("[useSolarHealth] staticCall failed:", staticCallError);
        }
        
        // Always send a real transaction to ensure FHE.allow is executed
        setMessage("Submitting transaction to authorize decryption...");
        const tx = await contract.calculateAverage(dates, category);
        console.log("[useSolarHealth] Transaction sent, waiting for confirmation...", tx.hash);
        const receipt = await tx.wait();
        console.log("[useSolarHealth] Transaction confirmed, receipt:", receipt);
        
        // Get the handle again after the transaction (authorization is now active)
        handle = await contract.calculateAverage.staticCall(dates, category);
        console.log("[useSolarHealth] Got handle after transaction:", handle);

        if (!handle || handle === "0x0000000000000000000000000000000000000000000000000000000000000000") {
          console.warn("[useSolarHealth] Handle is zero - no data available");
          setMessage("No data available for selected period");
          return BigInt(0); // Return 0 instead of null
        }

        // Note: calculateAverage already calls FHE.allowThis and FHE.allow internally
        // The transaction above ensures this authorization is executed on-chain
        setMessage("Loading decryption signature...");
        // Load or sign decryption signature
        const { FhevmDecryptionSignature } = await import("@/fhevm/FhevmDecryptionSignature");
        const sig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [contractAddress as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!sig) {
          throw new Error("Unable to build FHEVM decryption signature");
        }

        setMessage("Decrypting...");
        // Decrypt using userDecrypt
        console.log("[useSolarHealth] Calling userDecrypt with handle:", handle, "contractAddress:", contractAddress);
        const res = await instance.userDecrypt(
          [{ handle, contractAddress: contractAddress as `0x${string}` }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        console.log("[useSolarHealth] userDecrypt result:", res);
        console.log("[useSolarHealth] Looking for handle in result, handle:", handle);
        
        // Handle might be in different format - check both string and potentially different key
        const resMap = res as Record<string, bigint | undefined>;
        const decrypted = resMap[handle] ?? resMap[handle.toLowerCase()] ?? Object.values(res)[0];
        console.log("[useSolarHealth] Decrypted average value:", decrypted, "type:", typeof decrypted);
        
        if (decrypted === undefined || decrypted === null) {
          console.error("[useSolarHealth] Decrypted value is undefined/null. Result keys:", Object.keys(res));
          throw new Error("Failed to decrypt handle - decrypted value is undefined");
        }
        
        setMessage("Average calculated successfully!");
        
        // Return the decrypted value (even if 0)
        return decrypted;
      } catch (error: any) {
        console.error("[useSolarHealth] Calculate average error:", error);
        const errorMsg = error?.reason || error?.message || error?.toString() || "Failed to calculate average";
        setMessage(`Error: ${errorMsg}`);
        // Don't return null on error, return 0 instead so the UI can show it
        return BigInt(0);
      } finally {
        setIsCalculating(false);
      }
    },
    [instance, contract, ethersSigner, fhevmDecryptionSignatureStorage]
  );

  // Calculate trend
  const calculateTrend = useCallback(
    async (oldDate: number, newDate: number, category: number) => {
      if (!instance || !contract || !ethersSigner) {
        setMessage("FHEVM instance or contract not available");
        return null;
      }

      setIsCalculating(true);
      setMessage("");

      try {
        const contractAddress = await contract.getAddress();
        
        console.log("[useSolarHealth] Calling calculateTrend with oldDate:", oldDate, "newDate:", newDate, "category:", category);
        setMessage("Calling contract...");
        
        // IMPORTANT: staticCall() doesn't execute FHE.allow, so we MUST send a real transaction
        // to ensure the authorization (FHE.allow) is executed on-chain
        // First, try staticCall to get the handle for quick feedback
        let isRisingHandle: string;
        try {
          isRisingHandle = await contract.calculateTrend.staticCall(oldDate, newDate, category);
          console.log("[useSolarHealth] Got handle from staticCall (preview):", isRisingHandle);
        } catch (staticCallError: any) {
          console.log("[useSolarHealth] staticCall failed:", staticCallError);
        }
        
        // Always send a real transaction to ensure FHE.allow is executed
        setMessage("Submitting transaction to authorize decryption...");
        const tx = await contract.calculateTrend(oldDate, newDate, category);
        console.log("[useSolarHealth] Transaction sent, waiting for confirmation...", tx.hash);
        await tx.wait();
        console.log("[useSolarHealth] Transaction confirmed");
        
        // Get the handle again after the transaction (authorization is now active)
        isRisingHandle = await contract.calculateTrend.staticCall(oldDate, newDate, category);
        console.log("[useSolarHealth] Got handle after transaction:", isRisingHandle);
        
        if (!isRisingHandle || isRisingHandle === "0x0000000000000000000000000000000000000000000000000000000000000000") {
          console.warn("[useSolarHealth] Handle is zero - no data available");
          setMessage("No data available for selected dates");
          return null;
        }
        
        // Note: The contract already calls FHE.allowThis and FHE.allow internally
        // So we don't need to call allowDecryption again
        setMessage("Loading decryption signature...");
        
        // Load or sign decryption signature
        const { FhevmDecryptionSignature } = await import("@/fhevm/FhevmDecryptionSignature");
        const sig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [contractAddress as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!sig) {
          throw new Error("Unable to build FHEVM decryption signature");
        }

        setMessage("Decrypting...");
        // Decrypt boolean (ebool)
        console.log("[useSolarHealth] Calling userDecrypt with handle:", isRisingHandle);
        const res = await instance.userDecrypt(
          [{ handle: isRisingHandle, contractAddress: contractAddress as `0x${string}` }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        console.log("[useSolarHealth] userDecrypt result:", res);
        const resMap = res as Record<string, bigint | boolean | undefined>;
        const isRising = resMap[isRisingHandle] ?? resMap[isRisingHandle.toLowerCase()] ?? Object.values(res)[0];
        console.log("[useSolarHealth] Decrypted trend value:", isRising, "type:", typeof isRising);
        
        if (isRising === undefined || isRising === null) {
          console.error("[useSolarHealth] Decrypted value is undefined/null. Result keys:", Object.keys(res));
          throw new Error("Failed to decrypt handle - decrypted value is undefined");
        }
        
        setMessage("Trend calculated successfully!");
        // ebool decrypts to boolean
        return isRising === true ? "Rising" : "Falling";
      } catch (error: any) {
        console.error("[useSolarHealth] Calculate trend error:", error);
        
        // Extract error message from various possible formats
        let errorMsg = 
          error?.revert?.args?.[0] ||  // Solidity Error(string) format
          error?.reason ||             // Ethers error reason
          error?.message ||            // Standard error message
          error?.toString() ||          // Fallback to string
          "Failed to calculate trend";
        
        // Check if it's a "HealthRecord not found" error
        const errorStr = errorMsg.toLowerCase();
        if (errorStr.includes("healthrecord not found")) {
          errorMsg = "No health record found for one or both of the selected dates. Please record data for both dates first.";
        }
        
        setMessage(`Error: ${errorMsg}`);
        return null;
      } finally {
        setIsCalculating(false);
      }
    },
    [instance, contract, ethersSigner, fhevmDecryptionSignatureStorage]
  );

  // Set goal
  const setGoal = useCallback(
    async (category: number, targetValue: number, deadline: number) => {
      if (!instance || !contract || !ethersSigner) {
        setMessage("FHEVM instance or contract not available");
        return;
      }

      setIsRecording(true);
      setMessage("");

      try {
        const contractAddress = await contract.getAddress();
        const signerAddress = await ethersSigner.getAddress();
        
        // Create encrypted input
        const input = instance.createEncryptedInput(
          contractAddress,
          signerAddress
        );
        input.add16(targetValue);
        
        // Encrypt
        const enc = await input.encrypt();

        const tx = await contract.setGoal(
          category,
          enc.handles[0],
          enc.inputProof,
          deadline
        );

        await tx.wait();
        setMessage("Goal set successfully!");
      } catch (error: any) {
        setMessage(`Error: ${error.message || "Failed to set goal"}`);
        throw error;
      } finally {
        setIsRecording(false);
      }
    },
    [instance, contract, ethersSigner]
  );

  // Calculate steps trend
  const calculateStepsTrend = useCallback(
    async (oldDate: number, newDate: number) => {
      if (!instance || !contract || !ethersSigner) {
        setMessage("FHEVM instance or contract not available");
        return null;
      }

      setIsCalculating(true);
      setMessage("");

      try {
        const contractAddress = await contract.getAddress();
        
        console.log("[useSolarHealth] Calling calculateStepsTrend with oldDate:", oldDate, "newDate:", newDate);
        setMessage("Calling contract...");
        
        // IMPORTANT: staticCall() doesn't execute FHE.allow, so we MUST send a real transaction
        // to ensure the authorization (FHE.allow) is executed on-chain
        // First, try staticCall to get the handle for quick feedback
        let isRisingHandle: string;
        try {
          isRisingHandle = await contract.calculateStepsTrend.staticCall(oldDate, newDate);
          console.log("[useSolarHealth] Got handle from staticCall (preview):", isRisingHandle);
        } catch (staticCallError: any) {
          console.log("[useSolarHealth] staticCall failed:", staticCallError);
        }
        
        // Always send a real transaction to ensure FHE.allow is executed
        setMessage("Submitting transaction to authorize decryption...");
        const tx = await contract.calculateStepsTrend(oldDate, newDate);
        console.log("[useSolarHealth] Transaction sent, waiting for confirmation...", tx.hash);
        await tx.wait();
        console.log("[useSolarHealth] Transaction confirmed");
        
        // Get the handle again after the transaction (authorization is now active)
        isRisingHandle = await contract.calculateStepsTrend.staticCall(oldDate, newDate);
        console.log("[useSolarHealth] Got handle after transaction:", isRisingHandle);
        
        if (!isRisingHandle || isRisingHandle === "0x0000000000000000000000000000000000000000000000000000000000000000") {
          console.warn("[useSolarHealth] Handle is zero - no data available");
          setMessage("No data available for selected dates");
          return null;
        }
        
        // Note: The contract already calls FHE.allowThis and FHE.allow internally
        // So we don't need to call allowDecryption again
        setMessage("Loading decryption signature...");
        
        // Load or sign decryption signature
        const { FhevmDecryptionSignature } = await import("@/fhevm/FhevmDecryptionSignature");
        const sig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [contractAddress as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!sig) {
          throw new Error("Unable to build FHEVM decryption signature");
        }

        setMessage("Decrypting...");
        // Decrypt boolean (ebool)
        console.log("[useSolarHealth] Calling userDecrypt with handle:", isRisingHandle);
        const res = await instance.userDecrypt(
          [{ handle: isRisingHandle, contractAddress: contractAddress as `0x${string}` }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        console.log("[useSolarHealth] userDecrypt result:", res);
        const resMap2 = res as Record<string, bigint | boolean | undefined>;
        const isRising = resMap2[isRisingHandle] ?? resMap2[isRisingHandle.toLowerCase()] ?? Object.values(res)[0];
        console.log("[useSolarHealth] Decrypted steps trend value:", isRising, "type:", typeof isRising);
        
        if (isRising === undefined || isRising === null) {
          console.error("[useSolarHealth] Decrypted value is undefined/null. Result keys:", Object.keys(res));
          throw new Error("Failed to decrypt handle - decrypted value is undefined");
        }
        
        setMessage("Trend calculated successfully!");
        // ebool decrypts to boolean
        return isRising === true ? "Rising" : "Falling";
      } catch (error: any) {
        console.error("[useSolarHealth] Calculate steps trend error:", error);
        
        // Extract error message from various possible formats
        let errorMsg = 
          error?.revert?.args?.[0] ||  // Solidity Error(string) format
          error?.reason ||             // Ethers error reason
          error?.message ||            // Standard error message
          error?.toString() ||         // Fallback to string
          "Failed to calculate steps trend";
        
        // Check if it's a "HealthRecord not found" error
        const errorStr = errorMsg.toLowerCase();
        if (errorStr.includes("healthrecord not found")) {
          errorMsg = "No health record found for one or both of the selected dates. Please record steps data for both dates first.";
        }
        
        setMessage(`Error: ${errorMsg}`);
        return null;
      } finally {
        setIsCalculating(false);
      }
    },
    [instance, contract, ethersSigner, fhevmDecryptionSignatureStorage]
  );

  // Calculate health score
  const calculateHealthScore = useCallback(
    async (dates: number[]) => {
      if (!instance || !contract || !ethersSigner) {
        setMessage("FHEVM instance or contract not available");
        return null;
      }

      setIsCalculating(true);
      setMessage("");

      try {
        const contractAddress = await contract.getAddress();
        
        console.log("[useSolarHealth] Calling calculateHealthScore with dates:", dates);
        setMessage("Calling contract...");
        
        // IMPORTANT: staticCall() doesn't execute FHE.allow, so we MUST send a real transaction
        // to ensure the authorization (FHE.allow) is executed on-chain
        // First, try staticCall to get the handle for quick feedback
        let handle: string;
        try {
          handle = await contract.calculateHealthScore.staticCall(dates);
          console.log("[useSolarHealth] Got handle from staticCall (preview):", handle);
        } catch (staticCallError: any) {
          console.log("[useSolarHealth] staticCall failed:", staticCallError);
        }
        
        // Always send a real transaction to ensure FHE.allow is executed
        setMessage("Submitting transaction to authorize decryption...");
        const tx = await contract.calculateHealthScore(dates);
        console.log("[useSolarHealth] Transaction sent, waiting for confirmation...", tx.hash);
        const receipt = await tx.wait();
        console.log("[useSolarHealth] Transaction confirmed, receipt:", receipt);
        
        // Get the handle again after the transaction (authorization is now active)
        handle = await contract.calculateHealthScore.staticCall(dates);
        console.log("[useSolarHealth] Got handle after transaction:", handle);

        if (!handle || handle === "0x0000000000000000000000000000000000000000000000000000000000000000") {
          console.warn("[useSolarHealth] Handle is zero - no data available");
          setMessage("No data available for selected period");
          return BigInt(0);
        }

        // Note: calculateHealthScore already calls FHE.allowThis and FHE.allow internally
        // The transaction above ensures this authorization is executed on-chain
        setMessage("Loading decryption signature...");
        // Load or sign decryption signature
        const { FhevmDecryptionSignature } = await import("@/fhevm/FhevmDecryptionSignature");
        const sig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [contractAddress as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!sig) {
          throw new Error("Unable to build FHEVM decryption signature");
        }

        setMessage("Decrypting...");
        // Decrypt using userDecrypt
        console.log("[useSolarHealth] Calling userDecrypt with handle:", handle);
        const res = await instance.userDecrypt(
          [{ handle, contractAddress: contractAddress as `0x${string}` }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        console.log("[useSolarHealth] userDecrypt result:", res);
        const resMap3 = res as Record<string, bigint | undefined>;
        const decrypted = resMap3[handle] ?? resMap3[handle.toLowerCase()] ?? Object.values(res)[0];
        console.log("[useSolarHealth] Decrypted health score value:", decrypted, "type:", typeof decrypted);
        
        if (decrypted === undefined || decrypted === null) {
          console.error("[useSolarHealth] Decrypted value is undefined/null. Result keys:", Object.keys(res));
          throw new Error("Failed to decrypt handle - decrypted value is undefined");
        }
        
        setMessage("Health score calculated successfully!");
        return decrypted;
      } catch (error: any) {
        console.error("[useSolarHealth] Calculate health score error:", error);
        const errorMsg = error?.reason || error?.message || error?.toString() || "Failed to calculate health score";
        setMessage(`Error: ${errorMsg}`);
        return BigInt(0);
      } finally {
        setIsCalculating(false);
      }
    },
    [instance, contract, ethersSigner, fhevmDecryptionSignatureStorage]
  );

  // Risk assessment
  const riskAssessment = useCallback(
    async (dates: number[]) => {
      if (!instance || !contract || !ethersSigner) {
        setMessage("FHEVM instance or contract not available");
        return null;
      }

      setIsCalculating(true);
      setMessage("");

      try {
        const contractAddress = await contract.getAddress();
        
        console.log("[useSolarHealth] Calling riskAssessment with dates:", dates);
        setMessage("Calling contract...");
        
        // IMPORTANT: staticCall() doesn't execute FHE.allow, so we MUST send a real transaction
        // to ensure the authorization (FHE.allow) is executed on-chain
        // First, try staticCall to get the handle for quick feedback
        let handle: string;
        try {
          handle = await contract.riskAssessment.staticCall(dates);
          console.log("[useSolarHealth] Got handle from staticCall (preview):", handle);
        } catch (staticCallError: any) {
          console.log("[useSolarHealth] staticCall failed:", staticCallError);
        }
        
        // Always send a real transaction to ensure FHE.allow is executed
        setMessage("Submitting transaction to authorize decryption...");
        const tx = await contract.riskAssessment(dates);
        console.log("[useSolarHealth] Transaction sent, waiting for confirmation...", tx.hash);
        const receipt = await tx.wait();
        console.log("[useSolarHealth] Transaction confirmed, receipt:", receipt);
        
        // Get the handle again after the transaction (authorization is now active)
        handle = await contract.riskAssessment.staticCall(dates);
        console.log("[useSolarHealth] Got handle after transaction:", handle);
        
        if (!handle || handle === "0x0000000000000000000000000000000000000000000000000000000000000000") {
          console.warn("[useSolarHealth] Handle is zero - no data available");
          setMessage("No data available for selected period");
          return BigInt(0);
        }

        // Note: riskAssessment already calls FHE.allowThis and FHE.allow internally
        // The transaction above ensures this authorization is executed on-chain
        setMessage("Loading decryption signature...");
        // Load or sign decryption signature
        const { FhevmDecryptionSignature } = await import("@/fhevm/FhevmDecryptionSignature");
        const sig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [contractAddress as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!sig) {
          throw new Error("Unable to build FHEVM decryption signature");
        }

        setMessage("Decrypting...");
        // Decrypt euint8 (should be compatible with userDecrypt)
        console.log("[useSolarHealth] Calling userDecrypt with handle:", handle);
        const res = await instance.userDecrypt(
          [{ handle, contractAddress: contractAddress as `0x${string}` }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        console.log("[useSolarHealth] userDecrypt result:", res);
        const resMap4 = res as Record<string, bigint | undefined>;
        const decrypted = resMap4[handle] ?? resMap4[handle.toLowerCase()] ?? Object.values(res)[0];
        console.log("[useSolarHealth] Decrypted risk assessment value:", decrypted, "type:", typeof decrypted);
        
        if (decrypted === undefined || decrypted === null) {
          console.error("[useSolarHealth] Decrypted value is undefined/null. Result keys:", Object.keys(res));
          throw new Error("Failed to decrypt handle - decrypted value is undefined");
        }
        
        setMessage("Risk assessment completed successfully!");
        return decrypted;
      } catch (error: any) {
        console.error("[useSolarHealth] Risk assessment error:", error);
        const errorMsg = error?.reason || error?.message || error?.toString() || "Failed to assess risk";
        setMessage(`Error: ${errorMsg}`);
        return BigInt(0);
      } finally {
        setIsCalculating(false);
      }
    },
    [instance, contract, ethersSigner, fhevmDecryptionSignatureStorage]
  );

        // Get user dates
        const getUserDates = useCallback(async () => {
          if (!contract || !ethersReadonlyProvider) {
            return [];
          }

          try {
            const dates = await contract.getUserDates();
            return dates.map((d: bigint) => Number(d));
          } catch (error: any) {
            console.error("[useSolarHealth] Get user dates error:", error);
            return [];
          }
        }, [contract, ethersReadonlyProvider]);

        // Get active goals
        const getActiveGoals = useCallback(async () => {
          if (!contract || !ethersReadonlyProvider) {
            return [];
          }

          try {
            const goals = await contract.getActiveGoals();
            return goals || [];
          } catch (error: any) {
            console.error("[useSolarHealth] Get active goals error:", error);
            return [];
          }
        }, [contract, ethersReadonlyProvider]);

        return {
          contract,
          isDeployed,
          isRecording,
          isCalculating,
          message,
          recordHealthData,
          recordSteps,
          calculateAverage,
          calculateTrend,
          calculateStepsTrend,
          calculateHealthScore,
          riskAssessment,
          setGoal,
          getUserDates,
          getActiveGoals,
        };
      };

